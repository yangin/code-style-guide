# Restful API设计规范

*采用Restful Api设计风格，`URL定位资源，HTTP动词描述操作`。*

## 目录

  1. [协议](#协议)
  1. [域名](#域名)
  1. [版本控制](#版本控制)
  1. [路径规则](#路径规则)
  1. [请求方法](#请求方法)
  1. [命名规则](#命名规则)
  1. [请求规则](#请求规则)
  1. [返回格式](#返回格式)
  1. [状态码](#状态码)
  1. [错误处理](#错误处理)
  1. [设计原则](#设计原则)
  1. [前后端约定](#前后端约定)
  1. [评审清单](#评审清单)

## 协议

[1.1]() API 与客户端通讯协议主要包含 http 和 https，建议使用 https 确保交互数据的传输安全。

**[⬆ 返回顶部](#目录)**

## 域名

[2.1]() 应该尽量将API部署在专用域名之下，如<https://api.example.com>。

[2.2]() 如果确定API很简单，可以考虑放在主域名下，如<https://example.com/api/>。

**[⬆ 返回顶部](#目录)**

## 版本控制

[3.1]() 应该将API的版本号放入URL，如<https://api.example.com/v1/>。

**[⬆ 返回顶部](#目录)**

## 路径规则

[4.1]() 在restful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"(collection)。

```bash
# bad
https://api.example.com/v1/getArticle?id=1

# good
https://api.example.com/v1/articles/1
```

[4.2]() API中表示资源的名词尽量使用复数。

```bash
# bad
https://api.example.com/v1/article/1

# good
https://api.example.com/v1/articles/1
```

[4.3]() 问号用来过滤，将资源放入路径中

```bash
# bad
http://www.bewindoweb.com/get_article?id=1&page_index=1

# good
# id并不使用问号，是因为它是资源定位的一部分
http://www.bewindoweb.com/get_article/1?page_index=1
```

**[⬆ 返回顶部](#目录)**

## 请求方法

[5.1]() 推荐使用 GET、POST、PUT、PATCH、DELETE 等http动词进行请求，对于资源的具体操作类型。
> 为什么？构建restful api架构

### 常用的HTTP动词

| 请求方法  | SQL命令  | 使用场景                                        |
|---------- |--------- |------------------------------------------------ |
| GET       | SELECT   | 从服务器取出资源（一项或多项）                  |
| POST      | CREATE   | 在服务器新建一个资源                            |
| PUT       | UPDATE   | 在服务器更新资源（客户端提供改变后的完整资源）  |
| PATCH     | UPDATE   | 在服务器更新资源（客户端提供改变的属性）        |
| DELETE    | DELETE   | 从服务器删除资源                                |

### 不常用动词

| 请求方法  | 使用场景                                        |
|---------- |------------------------------------------------ |
| HEAD      | 获取资源的元数据                                |
| OPTIONS   | 获取信息，关于资源的哪些属性是客户端可以改变的  |

[5.2]() 基于安全性与幂等性原则，正确使用HTTP请求动词。

【安全性（Safety）】

无论请求多少次，都不会改变服务器的状态。

例如，无论使用Get请求多少次文章，都不会改变文章具体的数据。

【幂等性（Idempotent）】

无论对资源操作多少次，结果总是一样的。

例如，采用PUT提交修改后的文章，无论操作多少次，修改后的文章内容都是一样的；而用POST让银行卡余额减少200，每次POST之后银行卡的余额都会发生变化。

| 请求方法  | 安全性  | 幂等性  | 作用                                        |
|---------- |-------- |-------- |-------------------------------------------- |
| Get       | 安全    | 幂等    | 获取表示、变更时获取表示（缓存）            |
| Post      | 不安全  | 不幂等  | 服务端的实例号创建资源、创建子资源          |
| Put       | 不安全  | 幂等    | 客户端的实例号创建资源、替换的方式更新资源  |
| Patch     | 不安全  | 不幂等  | 部分更新资源                                |
| Delete    | 不安全  | 幂等    | 删除资源                                    |

**[⬆ 返回顶部](#目录)**

## 命名规则

[6.1]() 接口方法名、入参、返回值字段名用下划线“_”来连接，即蛇形结构。
> 为什么？ url大小写在各种类型服务器中的敏感程度不同，如Linux对大小写敏感，Windows对大小写不敏感等，为保持都能识别，统一采用snake写法。

```bash
# bad
http://www.bewindoweb.com/userInfo/1?page_index=1

# good
http://www.bewindoweb.com/user_info/1?pageIndex=1
```

**[⬆ 返回顶部](#目录)**

## 请求规则

### 分页请求

[7.1]() 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，分页返回结果。

下面是一些常见的参数

?record_count=10：返回记录的总数量。

?page_count=10：指定总页数。

?page_index=2&page_size=100：指定第几页，以及每页的记录数。

?sort_by=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。

**[⬆ 返回顶部](#目录)**

## 返回格式

[8.1]() 统一使用json格式返回，并按如下结构返回
> 为什么？ 方便前端解析返回内容，对错误信息做拦截处理。

```
{
    code: 0,                          //状态码
    msg: 'ok',                        //提示信息
    data: {}                          //主体数据
}
```

- code: 0为成功，非0为失败。可以自定义code，代表不同的错误码。
- msg: 当code为非0时，获取错误信息。当code为0时，msg一般为”ok”。如果有需要也可以另外作规定。
- data: 当code为0时，获取结果，全部以json方式表示。当code为非0时，data没有数据。

**[⬆ 返回顶部](#目录)**

## 状态码

服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。

[9.1]() `2`字开头状态码：成功
| 状态码  | 名称        | 说明                          |
|-------- |------------ |------------------------------ |
| 200     | OK          | 请求成功，用于PUT或PATCH请求  |
| 201     | Created     | 资源被成功创建，用于POST请求  |
| 202     | Accepted    | 请求成功，正在处理            |
| 204     | No Content  | 空内容，用于DELETE请求        |

[9.2]() `3`字开头状态码：添加必要的处理

3开头的状态码常被用于重定向操作。当客户端访问URI，服务器返回3开头的状态码时，响应消息里会返回名为Location的响应消息首部，其中包含了新的URI地址。

[9.3]() `4`字开头状态码：客户端请求发生问题
| 状态码    | 名称                    | 说明                          |
|--------- |------------------------ |------------------------------ |
| 400      | Bad Request             | 请求不正确                    |
| 401      | Unauthorized            | 需要认证                      |
| 403      | Forbidden               | 禁止访问                      |
| 404      | Not Found               | 没有找到指定资源              |
| 405      | Method Not Allowed      | HTTP请求类型出错              |
| 406      | Not Acceptable          | 不支持客户端指定的返回类型    |
| 408      | Request Timeout         | 服务端超时处理                |
| 409      | Confilct                | 资源冲突，例如邮箱地址被使用  |
| 410      | Gone                    | 资源曾经存在现在已消失        |
| 413/414  | RETL/RURL               | 请求体过长/请求URI过长        |
| 415      | Unsupported Media Type  | 不支持Content-Type里指定格式  |
| 429      | Too Many Request        | 限速：限制请求次数            |

[9.4]() `5`字开头状态码：服务器端发生问题
| 状态码  | 名称                   | 说明                      |
|-------- |----------------------- |-------------------------- |
| 500     | Internal Server Error  | 服务端发生错误            |
| 503     | Service Unavailable    | 服务器端不可用或暂停状态  |

**[⬆ 返回顶部](#目录)**

## 错误处理

[10.1]() 不要直接将异常抛给客户端处理，一般需要一个统一的异常处理类，并且以统一格式将异常信息返回前端，统一格式参照“# 返回格式”

[10.2]() 返回的错误信息，统一采用英文全拼大写，并用“_”连接，来表示错误原因，前端对返回原因进行文本映射。
> 为什么？ 多语言环境下，翻译工作由前端来处理。同时保证了后端代码层面的干净。

```bash
# bad
{
    code: 401,
    msg: '无效的cookie',
    data: {}
}

{
    code: 401,
    msg: 'invalid cookie',
    data: {}
}

# good
{
    code: 401,
    msg: 'INVALID_COOKIE',
    data: {}
}

```

**[⬆ 返回顶部](#目录)**

## 设计原则

[11.1]() 在满足需求并保证单一功能原则的情况下，尽量减少接口的数量。
> 为什么？ 每一个接口都会发起一次网络请求，每个请求都会有一个打开通信通道到关闭通道等链路流程，比较耗时。

[11.2]() 避免不必要的传参与返回值。
> 为什么？ 减少不必要的流量传输，同时保证了接口的简洁明了。

**[⬆ 返回顶部](#目录)**

## 前后端约定

### 后端

[12.1]() 后端需要保证JSON格式的合法性，前端不对格式的合法性做判断。

[12.2]() 金额格式：所有金额以元为单位，显示性的后台返回的是格式化之后的，例如：6,800。

[12.3]() 时间格式: 尽量以一致格式的字符串传递 2019-01-01 12:12:12。

[12.4]() 数据接口中定义的key集合是后端返回的子集，即key不缺失（参考数据格式，允许传递更多数据）。

[12.5]() key使用蛇形命名，即下划线“_”分割。

[12.6]() 空对象请使用{}。

[12.7]() 空列表请使用[]。

[12.8]() 空字符串请使用''。

[12.9]() 默认数字请使用0。

[12.10]() 尽量避免使用null undefined。

[12.11]() 响应头Content-Type为"application/json; charset=UTF-8"。

[12.12]() 接口应该携带requestId唯一标示用来追踪问题。

[12.13]() 敏感度高的数据，客户端和服务器通过约定的算法，对传递的参数值进行签名匹配，防止参数在请求过程中被抓取篡改。

[12.14]() 包含用户隐私的字段数据，需要加*号。如：手机号，身份证，用户邮箱，支付账号，邮寄地址等。

```bash
 "phone":"150*****000",
 "id_card":"3500**********0555", 
 "email":"40*****00@qq.com" 
```

### 前端

[12.15]() 请求头 application/x-www-form-urlencoded。

[12.16]() 请求字段使用蛇形命名，即下划线“_”分割。

[12.17]()  一个页面尽量只有一个拉取接口，减少类似这种的连续请求。

[12.18]() 当请求需要缓存并且有需要及时更新的情况，可以分多个请求。

**[⬆ 返回顶部](#目录)**

## 评审清单

[13.1]() URI 命名是否通过聚合根和实体统一

[13.2]() URI 命名是否采用名词复数和连接线

[13.3]() URI 命名是否都是单词小写

[13.4]() URI 是否暴露了不必要的信息，例如 /cgi-bin

[13.5]() URI 规则是否统一

[13.6]() 资源提供的能力是否彼此独立

[13.7]() URI 是否存在需要编码的字符

[13.8]() 请求和返回的参数是否不多不少

[13.9]() 资源的 ID 参数是否通过 PATH 参数传递

[13.10]() 认证和授权信息是否暴露到 query 参数中

[13.11]() 参数是否使用奇怪的缩写

[13.12]() 参数和响应数据中的字段命名统一

[13.13]() 是否存在无意义的对象包装 例如 {"data":{}'}

[13.14]() 出错时是否破坏约定的数据结构

[13.15]() 是否使用合适的状态码

[13.16]() 是否使用合适的媒体类型

[13.17]() 响应数据的单复是否和数据内容一致

[13.18]() 响应头中是否有缓存信息

[13.19]() 是否进行了版本管理

[13.20]() 版本信息是否作为 URI 的前缀存在

[13.21]() 是否提供 API 服务期限

[13.22]() 是否提供了 API 返回所有 API 的索引

[13.23]() 是否进行了认证和授权

[13.24]() 是否采用 HTTPS

[13.25]() 是否检查了非法参数

[13.26]() 是否增加安全性的头部

[13.27]() 是否有限流策略

[13.28]() 是否支持 CORS

[13.29]() 响应中的时间格式是否采用 ISO 8601 标准

[13.30]() 是否存在越权访问

**[⬆ 返回顶部](#目录)**
